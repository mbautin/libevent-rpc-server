/*
 * Automatically generated from ./QueryTypes.rpc
 * by event_rpcgen.py/0.1.  DO NOT EDIT THIS FILE.
 */

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <event2/event-config.h>
#include <event2/event.h>
#include <event2/buffer.h>
#include <event2/tag.h>

#ifdef EVENT____func__
#define __func__ EVENT____func__
#endif


#include "QueryTypes.gen.h"

void event_warn(const char *fmt, ...);
void event_warnx(const char *fmt, ...);


/*
 * Implementation of StatRequest
 */

static struct StatRequest_access_ StatRequest_base__ = {
  StatRequest_uptime_assign,
  StatRequest_uptime_get,
  StatRequest_uname_assign,
  StatRequest_uname_get,
};

struct StatRequest *
StatRequest_new(void)
{
  return StatRequest_new_with_arg(NULL);
}

struct StatRequest *
StatRequest_new_with_arg(void *unused)
{
  struct StatRequest *tmp;
  if ((tmp = malloc(sizeof(struct StatRequest))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &StatRequest_base__;

  tmp->uptime_data = 0;
  tmp->uptime_set = 0;

  tmp->uname_data = 0;
  tmp->uname_set = 0;

  return (tmp);
}



int
StatRequest_uptime_assign(struct StatRequest *msg, const ev_uint32_t value)
{
  msg->uptime_set = 1;
  msg->uptime_data = value;
  return (0);
}

int
StatRequest_uname_assign(struct StatRequest *msg, const ev_uint32_t value)
{
  msg->uname_set = 1;
  msg->uname_data = value;
  return (0);
}

int
StatRequest_uptime_get(struct StatRequest *msg, ev_uint32_t *value)
{
  if (msg->uptime_set != 1)
    return (-1);
  *value = msg->uptime_data;
  return (0);
}

int
StatRequest_uname_get(struct StatRequest *msg, ev_uint32_t *value)
{
  if (msg->uname_set != 1)
    return (-1);
  *value = msg->uname_data;
  return (0);
}

void
StatRequest_clear(struct StatRequest *tmp)
{
  tmp->uptime_set = 0;
  tmp->uname_set = 0;
}

void
StatRequest_free(struct StatRequest *tmp)
{
  free(tmp);
}

void
StatRequest_marshal(struct evbuffer *evbuf, const struct StatRequest *tmp){
  if (tmp->uptime_set) {
    evtag_marshal_int(evbuf, STATREQUEST_UPTIME, tmp->uptime_data);
  }
  if (tmp->uname_set) {
    evtag_marshal_int(evbuf, STATREQUEST_UNAME, tmp->uname_data);
  }
}

int
StatRequest_unmarshal(struct StatRequest *tmp,  struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case STATREQUEST_UPTIME:

        if (tmp->uptime_set)
          return (-1);
        if (evtag_unmarshal_int(evbuf, STATREQUEST_UPTIME, &tmp->uptime_data) == -1) {
          event_warnx("%s: failed to unmarshal uptime", __func__);
          return (-1);
        }
        tmp->uptime_set = 1;
        break;

      case STATREQUEST_UNAME:

        if (tmp->uname_set)
          return (-1);
        if (evtag_unmarshal_int(evbuf, STATREQUEST_UNAME, &tmp->uname_data) == -1) {
          event_warnx("%s: failed to unmarshal uname", __func__);
          return (-1);
        }
        tmp->uname_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (StatRequest_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
StatRequest_complete(struct StatRequest *msg)
{
  return (0);
}

int
evtag_unmarshal_StatRequest(struct evbuffer *evbuf, ev_uint32_t need_tag, struct StatRequest *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (StatRequest_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_StatRequest(struct evbuffer *evbuf, ev_uint32_t tag, const struct StatRequest *msg)
{
  struct evbuffer *buf_ = evbuffer_new();
  assert(buf_ != NULL);
  StatRequest_marshal(buf_, msg);
  evtag_marshal_buffer(evbuf, tag, buf_);
   evbuffer_free(buf_);
}

/*
 * Implementation of StatReply
 */

static struct StatReply_access_ StatReply_base__ = {
  StatReply_uptime_assign,
  StatReply_uptime_get,
  StatReply_uname_assign,
  StatReply_uname_get,
};

struct StatReply *
StatReply_new(void)
{
  return StatReply_new_with_arg(NULL);
}

struct StatReply *
StatReply_new_with_arg(void *unused)
{
  struct StatReply *tmp;
  if ((tmp = malloc(sizeof(struct StatReply))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &StatReply_base__;

  tmp->uptime_data = NULL;
  tmp->uptime_set = 0;

  tmp->uname_data = NULL;
  tmp->uname_set = 0;

  return (tmp);
}



int
StatReply_uptime_assign(struct StatReply *msg,
    const char * value)
{
  if (msg->uptime_data != NULL)
    free(msg->uptime_data);
  if ((msg->uptime_data = strdup(value)) == NULL)
    return (-1);
  msg->uptime_set = 1;
  return (0);
}

int
StatReply_uname_assign(struct StatReply *msg,
    const char * value)
{
  if (msg->uname_data != NULL)
    free(msg->uname_data);
  if ((msg->uname_data = strdup(value)) == NULL)
    return (-1);
  msg->uname_set = 1;
  return (0);
}

int
StatReply_uptime_get(struct StatReply *msg, char * *value)
{
  if (msg->uptime_set != 1)
    return (-1);
  *value = msg->uptime_data;
  return (0);
}

int
StatReply_uname_get(struct StatReply *msg, char * *value)
{
  if (msg->uname_set != 1)
    return (-1);
  *value = msg->uname_data;
  return (0);
}

void
StatReply_clear(struct StatReply *tmp)
{
  if (tmp->uptime_set == 1) {
    free(tmp->uptime_data);
    tmp->uptime_data = NULL;
    tmp->uptime_set = 0;
  }
  if (tmp->uname_set == 1) {
    free(tmp->uname_data);
    tmp->uname_data = NULL;
    tmp->uname_set = 0;
  }
}

void
StatReply_free(struct StatReply *tmp)
{
  if (tmp->uptime_data != NULL)
      free (tmp->uptime_data);
  if (tmp->uname_data != NULL)
      free (tmp->uname_data);
  free(tmp);
}

void
StatReply_marshal(struct evbuffer *evbuf, const struct StatReply *tmp){
  if (tmp->uptime_set) {
    evtag_marshal_string(evbuf, STATREPLY_UPTIME, tmp->uptime_data);
  }
  if (tmp->uname_set) {
    evtag_marshal_string(evbuf, STATREPLY_UNAME, tmp->uname_data);
  }
}

int
StatReply_unmarshal(struct StatReply *tmp,  struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case STATREPLY_UPTIME:

        if (tmp->uptime_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, STATREPLY_UPTIME, &tmp->uptime_data) == -1) {
          event_warnx("%s: failed to unmarshal uptime", __func__);
          return (-1);
        }
        tmp->uptime_set = 1;
        break;

      case STATREPLY_UNAME:

        if (tmp->uname_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, STATREPLY_UNAME, &tmp->uname_data) == -1) {
          event_warnx("%s: failed to unmarshal uname", __func__);
          return (-1);
        }
        tmp->uname_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (StatReply_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
StatReply_complete(struct StatReply *msg)
{
  return (0);
}

int
evtag_unmarshal_StatReply(struct evbuffer *evbuf, ev_uint32_t need_tag, struct StatReply *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (StatReply_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_StatReply(struct evbuffer *evbuf, ev_uint32_t tag, const struct StatReply *msg)
{
  struct evbuffer *buf_ = evbuffer_new();
  assert(buf_ != NULL);
  StatReply_marshal(buf_, msg);
  evtag_marshal_buffer(evbuf, tag, buf_);
   evbuffer_free(buf_);
}

